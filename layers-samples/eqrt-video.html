<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='apple-mobile-web-app-capable' content='yes'>
    <link rel='icon' type='image/png' sizes='32x32' href='../favicon-32x32.png'>
    <link rel='icon' type='image/png' sizes='96x96' href='../favicon-96x96.png'>
    <link rel='stylesheet' href='../css/common.css'>
    <title>WebXR Media Layers</title>
    <style>
      body {
        background-color: black;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        flex-direction: column;
      }
      img.logo {
        max-width: 400px;
        margin-bottom: 20px;
      }
      header {
        max-width: 800px;
        background-color: white;
        padding: 20px;
        border-radius: 10px;
      }
    </style>
  </head>
  <body>
    <img src="../media/logo/logo.jpg" alt="Logo" class="logo">
    <button id="xr-button" disabled>XR not found</button>
  </header hidden>
  <main style='text-align: center;'>
    <p>Click 'Enter VR' to see content</p>
  </main>
  <script type="module">
    import { WebXRButton } from '../js/util/webxr-button.js';
    import { Scene, WebXRView } from '../js/render/scenes/scene.js';
    import { Renderer, createWebGLContext } from '../js/render/core/renderer.js';
    import { QueryArgs } from '../js/util/query-args.js';
    import { MenuSystem } from '../js/render/nodes/menu-system.js';

    // If requested, use the polyfill to provide support for mobile devices
    // and devices which only support WebVR.
    import WebXRPolyfill from '../js/third-party/webxr-polyfill/build/webxr-polyfill.module.js';
    if (QueryArgs.getBool('usePolyfill', true)) {
      let polyfill = new WebXRPolyfill();
    }

    // XR globals.
    let xrButton = null;
    let xrSession = null;
    let xrRefSpace = null;
    let xrGLFactory = null;
    let xrFramebuffer = null;
    let stereoUtil = null;

    // WebGL scene globals.
    let gl = null;
    let renderer = null;
    let scene = new Scene();

    // Layer globals
    let projLayer = null;
    let eqrtLayer = null;
    let eqrtVideoElement = null;
    let eqrtVideoWidth = 0;
    let eqrtVideoHeight = 0;
    let eqrtVideoNeedsUpdate = false;

    // Set up media control bar
    let menuSystem = new MenuSystem();
    menuSystem.createButton('../media/textures/backward-button.png', () => { eqrtVideoElement.currentTime -= 15; });
    menuSystem.createSwitch(
      '../media/textures/pause-button.png', () => eqrtVideoElement.pause(),
      '../media/textures/play-button.png', () => eqrtVideoElement.play()
    );
    menuSystem.createButton('../media/textures/forward-button.png', () => { eqrtVideoElement.currentTime += 15; });
    menuSystem.createButton('../media/textures/x-button.png', () => { xrSession.end() });
    scene.addNode(menuSystem.getMenuBarNode());

    function initXR() {
      xrButton = new WebXRButton({
        onRequestSession: onRequestSession,
        onEndSession: onEndSession
      });
      document.querySelector('header').appendChild(xrButton.domElement);

      if (navigator.xr) {
        navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
          xrButton.enabled = supported;
        });
      }
    }

    function onRequestSession() {
      if (!xrSession) {
        navigator.xr.requestSession('immersive-vr', {
          requiredFeatures: ['layers'],
        }).then(onSessionStarted);
      } else {
        onEndSession();
      }
    }

    function initGL() {
      if (gl) { return; }
      gl = createWebGLContext({ xrCompatible: true, webgl2: true, });
      document.body.appendChild(gl.canvas);
      gl.clearColor(0.0, 0, 0, 0.0);

      function onResize() {
        gl.canvas.width = gl.canvas.clientWidth * window.devicePixelRatio;
        gl.canvas.height = gl.canvas.clientHeight * window.devicePixelRatio;
      }
      window.addEventListener('resize', onResize);
      onResize();

      renderer = new Renderer(gl);
      scene.setRenderer(renderer);

      // Util for rendering stereo layers
      stereoUtil = new VRStereoUtil(gl);
    }

    function onSessionStarted(session) {
      xrSession = session;
      scene.inputRenderer.useProfileControllerMeshes(session);
      session.addEventListener('end', onSessionEnded);

      initGL();

      xrFramebuffer = gl.createFramebuffer();
      xrGLFactory = new XRWebGLBinding(session, gl);

      let selected = document.getElementById("eqrtVideoSelect");
      eqrtVideoElement = document.createElement('video');
      eqrtVideoElement.loop = true;
      eqrtVideoElement.crossOrigin = "anonymous";
      eqrtVideoElement.preload = 'auto';
      eqrtVideoElement.autoload = true;
      eqrtVideoElement.src = selected.options[selected.selectedIndex].value;
      eqrtVideoWidth = selected.options[selected.selectedIndex].getAttribute("data-video-width");
      eqrtVideoHeight = selected.options[selected.selectedIndex].getAttribute("data-video-height");
      let eqrtVideoAngle = selected.options[selected.selectedIndex].getAttribute("data-video-angle");
      let eqrtVideoLayout = selected.options[selected.selectedIndex].getAttribute("data-video-layout");
      let eqrtRadius = 10;
      let eqrtVideoFPS = selected.options[selected.selectedIndex].getAttribute("data-video-fps");


      eqrtVideoElement.play();
      setInterval(function () {
        if (eqrtVideoElement.readyState >= eqrtVideoElement.HAVE_CURRENT_DATA) {
          eqrtVideoNeedsUpdate = true;
        }
      }, 1000 / eqrtVideoFPS);

      session.requestReferenceSpace('local').then((refSpace) => {
        xrRefSpace = refSpace;
        projLayer = xrGLFactory.createProjectionLayer({ space: refSpace, stencil: false });
        eqrtLayer = xrGLFactory.createEquirectLayer({
          space: refSpace,
          viewPixelWidth: eqrtVideoWidth / (eqrtVideoLayout === "stereo-left-right" ? 2 : 1),
          viewPixelHeight: eqrtVideoHeight / (eqrtVideoLayout === "stereo-top-bottom" ? 2 : 1),
          layout: eqrtVideoLayout,
        });

        eqrtLayer.centralHorizontalAngle = Math.PI * eqrtVideoAngle / 180;
        eqrtLayer.upperVerticalAngle = Math.PI / 2.0;
        eqrtLayer.lowerVerticalAngle = -Math.PI / 2.0;
        eqrtLayer.radius = eqrtRadius;
        session.updateRenderState({ layers: [eqrtLayer, projLayer] });

        session.requestAnimationFrame(onXRFrame);
      });
    }

    function onEndSession() {
      xrSession.end();
    }

    function onSessionEnded(event) {
      if (event.session.isImmersive) {
        xrButton.setSession(null);
      }
      xrSession = null;
      eqrtVideoElement.pause();
      gl = null;
    }

    function buttonPressedThisFrame(gamepad, index) {
      return (index < gamepad.buttons.length &&
        gamepad.buttons[index].pressed);
    }

    function onXRFrame(time, frame) {
      let pose = frame.getViewerPose(xrRefSpace);
      xrSession.requestAnimationFrame(onXRFrame);

      if (eqrtLayer && (eqrtVideoNeedsUpdate || eqrtLayer.needsRedraw)) {
        eqrtVideoNeedsUpdate = false;
        let glayer = xrGLFactory.getSubImage(eqrtLayer, frame);

        // TEXTURE_CUBE_MAP expects the Y to be flipped for the faces and it already
        // is flipped in our texture image.
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.bindTexture(gl.TEXTURE_2D, glayer.colorTexture);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, eqrtVideoWidth, eqrtVideoHeight, gl.RGBA, gl.UNSIGNED_BYTE, eqrtVideoElement);
        gl.bindTexture(gl.TEXTURE_2D, null);
      }

      let force_mono = false;
      for (let source of xrSession.inputSources) {
        force_mono |= buttonPressedThisFrame(source.gamepad, 4);
      }
      eqrtLayer.forceMonoPresentation = force_mono;

      if (pose) {
        gl.bindFramebuffer(gl.FRAMEBUFFER, xrFramebuffer);
        // We need to invalidate the color (and depth, just in case) here to avoid
        // loading from the previously bound color texture. It will save some GPU time.
        gl.invalidateFramebuffer(gl.FRAMEBUFFER, [gl.COLOR_ATTACHMENT0, gl.DEPTH_ATTACHMENT]);

        scene.updateInputSources(frame, xrRefSpace);
        menuSystem.processInput(frame, scene, xrRefSpace);

        let views = [];
        for (let view of pose.views) {
          let viewport = null;
          let glLayer = xrGLFactory.getViewSubImage(projLayer, view);
          glLayer.framebuffer = xrFramebuffer;
          viewport = glLayer.viewport;
          gl.bindFramebuffer(gl.FRAMEBUFFER, xrFramebuffer);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, glLayer.colorTexture, 0);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, glLayer.depthStencilTexture, 0);
          views.push(new WebXRView(view, glLayer, viewport));
        }
        scene.drawViewArray(views);
      }
      scene.endFrame();
    }

    initXR();
  </script>
</body>

</html>
